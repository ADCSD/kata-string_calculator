{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kata String Calculator TDD Beginner Descripci\u00f3n de la Kata La Kata String Calculator es una kata muy sencilla, que permite al desarrollador iniciarse en el mundo del TDD, gracias a los requisitos bien estructurados e incrementales. Tambi\u00e9n es una buena kata para aprender un lenguaje, al ser sencilla se aprende la estructura de proyecto, de tests y de llamadas del lenguaje. Enunciado La famosa empresa de calculadoras \u201cCasio\u201d ha contratado los servicios de nuestra compa\u00f1\u00eda. Quieren lanzar al mercado un nuevo concepto de calculadora basada en proceso de texto. El problema es que \u201cCasio\u201d es un cliente un poco dif\u00edcil, no tiene claros los requisitos y quiere resultados inmediatos, sin perder funcionalidad ya implementada. Al frente del proyecto ha puesto a los mejores ingenieros que, con ayuda de TDD, intentar\u00e1n dar respuesta a los requisitos cambiantes sin romper ninguna funcionalidad previa. \u00bfComo podemos ayudar a Casio? Requisitos Crea una String Calculator con el m\u00e9todo: int add(String input) El par\u00e1metro del m\u00e9todo puede contener 0, 1 o 2 n\u00fameros y devolver\u00e1 su suma (para un string vac\u00edo devolver\u00e1 0). Por ejempo: \"\" o \"1\" o \"1,2\u201d Comieza por un test simple para un string vac\u00edo y luego para 1 y 2 n\u00fameros. Recuerda resolver el problema de la manera m\u00e1s simple posible para que te fuerce a escribir las pruebas que a\u00fan no se te hab\u00edan ocurrido. Recuerda refactorizar despu\u00e9s de conseguir pasar cada test. Permite al metodo \u201cadd\" manejar cualquier cantidad de n\u00fameros. Permite al m\u00e9todo \"add\" manejar saltos de l\u00ednea entre n\u00fameros en lugar de usar comas. La siguiente entrada es correcta: \"1\\n2,3\" (el resultado ser\u00e1 6) La siguiente entrada NO es correcta: \"1,\\n\" (no hace falta que la pruebes, es simplemente para clarificar) Soporta diferentes delimitadores Para cambiar un delimitador, el comienzo del string debe contener una l\u00ednea separada que sea como esta: \"//[delimitador]\\n[n\u00fameros...]\". Por ejemplo: \"//;\\n1;2\" debe dar como resultado 3 donde el delimitador por defecto es \";\". La primera l\u00ednea es opcional. Todos los escenarios existentes hasta ahora, deben estar soportados. Llamar al m\u00e9todo \u201cadd\" con n\u00fameros negativos deber\u00e1 lanzar una excepci\u00f3n con el texto \"negativos no soportados\" y el n\u00famero negativo que ha sido pasado. Si hay m\u00faltiples n\u00fameros negativos, muestra todos ellos en el mensaje de la excepci\u00f3n. Los numeros mayores de 1000 deben ser ignorados. Por ejemplo \"2,1001\" dar\u00e1 como resultado 2. Los delimitadores pueden ser de cualquier longitud con el siguiente formato: \"//[delimiter]\\n\". Por ejemplo: \"//[;;;]\\n1;;;2;;;3\" debe dar como resultado 6. Permite m\u00faltiples delimitadores de la siguiente manera: \"//[delim1][delim2]\\n\". Por ejemplo: \"//[#][%]\\n1#2%3\" debe dar como resultado 6. Aseg\u00farate de que puedes manejar delimitadores de cualquier longitud mayor de un caracter. Consejos para desarrollo Intentaremos no leer el enunciado completo. Iremos leyendo poco a poco. Haremos solo una tarea a la vez. Tenemos que aprender a trabajar de forma incremental. Para esta kata solo vamos a testear las entradas correctas. Por agilidad en la session. Llegaremos hasta donde nos de tiempo. No se trata de terminarlo, sino de aprender durante el proceso. Programaremos entre todos. No existe una soluci\u00f3n correcta y una incorrecta, se puede hacer de muchas formas. No te olvides de pasar los tests a cada cambio que se efectue del c\u00f3digo, para verificar que funciona todo correctamente y que no se ha roto nada m\u00e1s. Fuente La kata ha sido extraida de Solveet Soluciones Todas las posibles soluciones las pod\u00e9is ver en el Github de ADCSD Original . Es el proyecto vac\u00edo original con el que empezar el ejercicio Kata-sesion . Es el proyecto tal y como qued\u00f3 despu\u00e9s de hacer una sesi\u00f3n de CodingDojo Solucion . Es el proyecto resuelto por completo que iremos viendo poco a poco en los siguientes cap\u00edtulos","title":"Introducci\u00f3n"},{"location":"#kata-string-calculator","text":"TDD Beginner","title":"Kata String Calculator"},{"location":"#descripcion-de-la-kata","text":"La Kata String Calculator es una kata muy sencilla, que permite al desarrollador iniciarse en el mundo del TDD, gracias a los requisitos bien estructurados e incrementales. Tambi\u00e9n es una buena kata para aprender un lenguaje, al ser sencilla se aprende la estructura de proyecto, de tests y de llamadas del lenguaje.","title":"Descripci\u00f3n de la Kata"},{"location":"#enunciado","text":"La famosa empresa de calculadoras \u201cCasio\u201d ha contratado los servicios de nuestra compa\u00f1\u00eda. Quieren lanzar al mercado un nuevo concepto de calculadora basada en proceso de texto. El problema es que \u201cCasio\u201d es un cliente un poco dif\u00edcil, no tiene claros los requisitos y quiere resultados inmediatos, sin perder funcionalidad ya implementada. Al frente del proyecto ha puesto a los mejores ingenieros que, con ayuda de TDD, intentar\u00e1n dar respuesta a los requisitos cambiantes sin romper ninguna funcionalidad previa. \u00bfComo podemos ayudar a Casio?","title":"Enunciado"},{"location":"#requisitos","text":"Crea una String Calculator con el m\u00e9todo: int add(String input) El par\u00e1metro del m\u00e9todo puede contener 0, 1 o 2 n\u00fameros y devolver\u00e1 su suma (para un string vac\u00edo devolver\u00e1 0). Por ejempo: \"\" o \"1\" o \"1,2\u201d Comieza por un test simple para un string vac\u00edo y luego para 1 y 2 n\u00fameros. Recuerda resolver el problema de la manera m\u00e1s simple posible para que te fuerce a escribir las pruebas que a\u00fan no se te hab\u00edan ocurrido. Recuerda refactorizar despu\u00e9s de conseguir pasar cada test. Permite al metodo \u201cadd\" manejar cualquier cantidad de n\u00fameros. Permite al m\u00e9todo \"add\" manejar saltos de l\u00ednea entre n\u00fameros en lugar de usar comas. La siguiente entrada es correcta: \"1\\n2,3\" (el resultado ser\u00e1 6) La siguiente entrada NO es correcta: \"1,\\n\" (no hace falta que la pruebes, es simplemente para clarificar) Soporta diferentes delimitadores Para cambiar un delimitador, el comienzo del string debe contener una l\u00ednea separada que sea como esta: \"//[delimitador]\\n[n\u00fameros...]\". Por ejemplo: \"//;\\n1;2\" debe dar como resultado 3 donde el delimitador por defecto es \";\". La primera l\u00ednea es opcional. Todos los escenarios existentes hasta ahora, deben estar soportados. Llamar al m\u00e9todo \u201cadd\" con n\u00fameros negativos deber\u00e1 lanzar una excepci\u00f3n con el texto \"negativos no soportados\" y el n\u00famero negativo que ha sido pasado. Si hay m\u00faltiples n\u00fameros negativos, muestra todos ellos en el mensaje de la excepci\u00f3n. Los numeros mayores de 1000 deben ser ignorados. Por ejemplo \"2,1001\" dar\u00e1 como resultado 2. Los delimitadores pueden ser de cualquier longitud con el siguiente formato: \"//[delimiter]\\n\". Por ejemplo: \"//[;;;]\\n1;;;2;;;3\" debe dar como resultado 6. Permite m\u00faltiples delimitadores de la siguiente manera: \"//[delim1][delim2]\\n\". Por ejemplo: \"//[#][%]\\n1#2%3\" debe dar como resultado 6. Aseg\u00farate de que puedes manejar delimitadores de cualquier longitud mayor de un caracter.","title":"Requisitos"},{"location":"#consejos-para-desarrollo","text":"Intentaremos no leer el enunciado completo. Iremos leyendo poco a poco. Haremos solo una tarea a la vez. Tenemos que aprender a trabajar de forma incremental. Para esta kata solo vamos a testear las entradas correctas. Por agilidad en la session. Llegaremos hasta donde nos de tiempo. No se trata de terminarlo, sino de aprender durante el proceso. Programaremos entre todos. No existe una soluci\u00f3n correcta y una incorrecta, se puede hacer de muchas formas. No te olvides de pasar los tests a cada cambio que se efectue del c\u00f3digo, para verificar que funciona todo correctamente y que no se ha roto nada m\u00e1s.","title":"Consejos para desarrollo"},{"location":"#fuente","text":"La kata ha sido extraida de Solveet","title":"Fuente"},{"location":"#soluciones","text":"Todas las posibles soluciones las pod\u00e9is ver en el Github de ADCSD Original . Es el proyecto vac\u00edo original con el que empezar el ejercicio Kata-sesion . Es el proyecto tal y como qued\u00f3 despu\u00e9s de hacer una sesi\u00f3n de CodingDojo Solucion . Es el proyecto resuelto por completo que iremos viendo poco a poco en los siguientes cap\u00edtulos","title":"Soluciones"},{"location":"step0/","text":"Preparaci\u00f3n Proyecto original El proyecto original preparado para realizar la Kata se puede descargar del Github de ADCSD e importarlo directamente en el IDE de desarrollo. Debes descargar el proyecto que est\u00e1 dentro de la carpeta original . Estructura de proyecto Se trata de un proyecto escrito en Java con maven, que consta de dos clases vac\u00edas: TestStringCalculator y TestStringCalculator . Aclaraciones Vamos a tratar de ver con mucho detalle y paso por paso la implementaci\u00f3n y su Refactor durante los primeros Requisitos , pero a medida que vayamos avanzando iremos resumiendo para que no se haga eterno el documento. Obviamente existen much\u00edsimas formas de implementar este ejercicio, lo que veremos a continuaci\u00f3n no es m\u00e1s que una de esas formas, ni mejor ni peor que cualquier otra. Es posible que tu tengas otra diferente, perfecto, tambi\u00e9n es v\u00e1lida. Adem\u00e1s, el nivel de Refactoring que vamos a ver en este ejercicio est\u00e1 pensado para explicar ciertas t\u00e9cnicas o acciones m\u00e1s habituales. Esto no quiere decir que siempre se deba llegar a este nivel, ni mucho menos, o que solo exista una forma de realizar el Refactoring . Al igual que las implementaciones, hay muchas formas de refactorizar, cada uno deber\u00eda quedarse en el nivel de refactorizaci\u00f3n con el que se sienta m\u00e1s c\u00f3modo. Debemos buscar un compromiso entre el tiempo dedicado y la facilidad de lectura que estamos dejando, pero sin obsesionarnos.","title":"Preparaci\u00f3n"},{"location":"step0/#preparacion","text":"","title":"Preparaci\u00f3n"},{"location":"step0/#proyecto-original","text":"El proyecto original preparado para realizar la Kata se puede descargar del Github de ADCSD e importarlo directamente en el IDE de desarrollo. Debes descargar el proyecto que est\u00e1 dentro de la carpeta original .","title":"Proyecto original"},{"location":"step0/#estructura-de-proyecto","text":"Se trata de un proyecto escrito en Java con maven, que consta de dos clases vac\u00edas: TestStringCalculator y TestStringCalculator .","title":"Estructura de proyecto"},{"location":"step0/#aclaraciones","text":"Vamos a tratar de ver con mucho detalle y paso por paso la implementaci\u00f3n y su Refactor durante los primeros Requisitos , pero a medida que vayamos avanzando iremos resumiendo para que no se haga eterno el documento. Obviamente existen much\u00edsimas formas de implementar este ejercicio, lo que veremos a continuaci\u00f3n no es m\u00e1s que una de esas formas, ni mejor ni peor que cualquier otra. Es posible que tu tengas otra diferente, perfecto, tambi\u00e9n es v\u00e1lida. Adem\u00e1s, el nivel de Refactoring que vamos a ver en este ejercicio est\u00e1 pensado para explicar ciertas t\u00e9cnicas o acciones m\u00e1s habituales. Esto no quiere decir que siempre se deba llegar a este nivel, ni mucho menos, o que solo exista una forma de realizar el Refactoring . Al igual que las implementaciones, hay muchas formas de refactorizar, cada uno deber\u00eda quedarse en el nivel de refactorizaci\u00f3n con el que se sienta m\u00e1s c\u00f3modo. Debemos buscar un compromiso entre el tiempo dedicado y la facilidad de lectura que estamos dejando, pero sin obsesionarnos.","title":"Aclaraciones"},{"location":"step1/","text":"Desarrollo del requisito 1 Requisito Crea una String Calculator con el m\u00e9todo: int add(String input) El par\u00e1metro del m\u00e9todo puede contener 0, 1 o 2 n\u00fameros y devolver\u00e1 su suma (para un string vac\u00edo devolver\u00e1 0). Por ejempo: \"\" o \"1\" o \"1,2\u201d Comieza por un test simple para un string vac\u00edo y luego para 1 y 2 n\u00fameros. Recuerda resolver el problema de la manera m\u00e1s simple posible para que te fuerce a escribir las pruebas que a\u00fan no se te hab\u00edan ocurrido. Recuerda refactorizar despu\u00e9s de conseguir pasar cada test. Desarrollo Empezamos la codificaci\u00f3n Como siempre, en TDD, empezamos creando el test unitario que cubra el primer requisito. Vamos a empezar con la primera parte del requisito y vamos a testear la cadena vac\u00eda. Para ello a\u00f1adimos un test: TestStringCalculator 1 2 3 4 5 6 @Test public void empty_string_return_zero () { StringCalculator calculator = new StringCalculator (); Assert . assertEquals ( 0 , calculator . add ( \"\" )); } Recuerda Recuerda que los nombres de los tests deben ser descriptivos, para que no sea necesario leer el c\u00f3digo del test para saber lo que realiza. Con leer el nombre del m\u00e9todo deber\u00eda ser suficiente para saber lo que hace. Obviamente si ejecutamos el test, obtendremos un test fail en rojo ya que nuestro c\u00f3digo no cumple con lo esperado por el test. El siguiente paso en TDD es realizar la implementaci\u00f3n m\u00ednima que haga funcionar los tests. StringCalculator 1 2 3 4 public int add ( String input ) { return 0 ; } La implementaci\u00f3n m\u00ednima que se me ocurre ahora mismo y que pasar\u00eda todos los tests actuales es esta. Ahora si ejecutamos, obtenemos una ejecuci\u00f3n correcta en verde. El siguiente paso paso en TDD ser\u00eda realizar el Refactoring . Aunque se podr\u00eda aplicar alguna acci\u00f3n, vamos a dejarlo pasar hasta tener algo m\u00e1s de c\u00f3digo, donde ya empecemos a detectar ciertos smells . Segundo test unitario Vamos con el segundo test. En esta ocasi\u00f3n vamos a probar que si la entrada es un n\u00famero debe devolver ese n\u00fameros. De nuevo hacemos el test para probar, fallar\u00e1, e implementaremos el c\u00f3digo m\u00ednimo para que cumpla con todos los tests y dejarlo en un estado correcto en verde. TestStringCalculator 1 2 3 4 5 6 7 8 @Test public void one_number_return_this_number () { StringCalculator calculator = new StringCalculator (); Assert . assertEquals ( 1 , calculator . add ( \"1\" )); Assert . assertEquals ( 2 , calculator . add ( \"2\" )); Assert . assertEquals ( 13 , calculator . add ( \"13\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 public int add ( String input ) { if ( input . equals ( \"\" )) return 0 ; else return Integer . parseInt ( input ); } Ahora que tenemos la aplicaci\u00f3n estable, en verde, y tenemos un poco m\u00e1s de c\u00f3digo podemos empezar a realizar el Refactoring . StringCalculator 1 2 3 4 5 6 7 8 9 public int add ( String input ) { if ( input . equals ( \"\" )) /*(1)*/ return 0 ; else /*(2)*/ return Integer . parseInt ( input ); } StringCalculator-Refactor-1 1 2 3 4 5 6 7 8 public int add ( String input ) { if ( \"\" . equals ( input )) /*(3)*/ return 0 ; /*(3)*/ return Integer . parseInt ( input ); } StringCalculator-Refactor-2 1 2 3 4 5 6 7 8 9 10 11 12 private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; return Integer . parseInt ( input ); } Refactoring (1) Tal y como est\u00e1 escrito, si la entrada input fuera null, en esa l\u00ednea nos saltar\u00eda un NullPointerException . Hay varias formas en las que podr\u00edamos corregirlo, o bien utilizando librer\u00edas de utilidades sobre String como las de ApacheUtils que ya hacen comprobaciones, o bien a\u00f1adiendo una comprobaci\u00f3n previa input != null , o bien simplemente d\u00e1ndole la vuelta al equals. Sabemos que la cadena vac\u00eda nunca va a ser nula, as\u00ed que si le damos la vuelta no puede saltar un NullPointerException . (2) La clausula else la podemos eliminar ya que no aporta nada al c\u00f3digo. Cuando programemos, debemos tener en cuenta que todos los condicionales if , if else y else , obligan al cerebro a tener que recordar cual era la condici\u00f3n anterior e ir acumul\u00e1ndolas. En este caso el else nos obliga a pensar que antes hab\u00eda un if que dec\u00eda si la cadena era vac\u00eda, as\u00ed que en este caso se ejecutar\u00e1 cuando la cadena no sea vac\u00eda. Esto se puede arreglar f\u00e1cil metiendo operaciones de return y simplificando el nivel de los if y else . (3) Tanto la cadena vac\u00eda como el n\u00famero 0 son smells de tipo Magic Number . En este caso est\u00e1 bastante claro que se trata de una entrada vac\u00eda y el resultado cero, pero est\u00e1 bien acostumbrarnos a tener todas esas variables o resultados por defecto en constantes. De nuevo la nomenclatura es importante, el nombre de la constante debe describir para que vamos a utilizar ese valor. No sirve con poner ZERO o EMPTY_STRING porque eso ya lo sabemos al ver el valor. Debemos ponerle un nombre acorde con la funcionalidad de ese valor. Cuando realizamos Refactoring del c\u00f3digo no debemos olvidar que los jUnits tambi\u00e9n forman parte del c\u00f3digo, as\u00ed que tambi\u00e9n son susceptibles de hacerles Refactoring . As\u00ed que vamos a ello: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void empty_string_return_zero () { StringCalculator calculator = new StringCalculator (); /*(1)*/ Assert . assertEquals ( 0 , calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { StringCalculator calculator = new StringCalculator (); /*(1)*/ Assert . assertEquals ( 1 , calculator . add ( \"1\" )); Assert . assertEquals ( 2 , calculator . add ( \"2\" )); Assert . assertEquals ( 13 , calculator . add ( \"13\" )); } TestStringCalculator-Refactor-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } Refactoring (1) Existe c\u00f3digo duplicado en los test y tiene pinta de que se va a duplicar m\u00e1s veces, as\u00ed que es una buena pr\u00e1ctica extraer el c\u00f3digo duplicado a una variable o m\u00e9todo externo. Tercer test unitario Vamos con el tercer y \u00faltimo test de este requisito. En esta ocasi\u00f3n vamos a probar que si la entrada son dos n\u00fameros separados por coma, debe devolver la suma de esos n\u00fameros. De nuevo hacemos el test para probar, fallar\u00e1, e implementaremos el c\u00f3digo m\u00ednimo para que cumpla con todos los tests y dejarlo en un estado correcto en verde. TestStringCalculator 1 2 3 4 5 6 @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( \",\" )) { String aux [] = input . split ( \",\" ); return Integer . parseInt ( aux [ 0 ] ) + Integer . parseInt ( aux [ 1 ] ); } return Integer . parseInt ( input ); } De nuevo, como tenemos estables el c\u00f3digo y los tests funcionando, es hora de hacer Refactoring . StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( \",\" )) { /*(1)*/ String aux [] = input . split ( \",\" ); /*(1)*/ /*(2)*/ return Integer . parseInt ( aux [ 0 ] ) + Integer . parseInt ( aux [ 1 ] ); /*(2)*/ } return Integer . parseInt ( input ); } StringCalculator-Refactor-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); return Integer . parseInt ( numbers [ 0 ] ) + Integer . parseInt ( numbers [ 1 ] ); } return Integer . parseInt ( input ); } Refactoring (1) De nuevo tenemos un Magic Number que podemos extraer a una constante. En este caso la hemos llamado DELIMITER porque encaja bien con la sem\u00e1ntica que se le quiere dar a la coma. (2) Aqu\u00ed el nombre de la variable no es nada descriptivo. Tendemos a ahorrarnos caracteres al escribir nombres de variables y m\u00e9todos, cuando no nos cobran por escribir m\u00e1s, y no penalizamos el rendimiento. Un nombre de variable m\u00e1s correcto podr\u00eda ser numbers , ya que es lo que vamos a almacenar en este vector. Resultado final Llegados a este punto y con estos tests ya tendr\u00edamos cubiertos este primer requisito. Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class StringCalculator { private static final String DELIMITER = \",\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); return Integer . parseInt ( numbers [ 0 ] ) + Integer . parseInt ( numbers [ 1 ] ); } return Integer . parseInt ( input ); } }","title":"R1. Suma dos n\u00fameros"},{"location":"step1/#desarrollo-del-requisito-1","text":"","title":"Desarrollo del requisito 1"},{"location":"step1/#requisito","text":"Crea una String Calculator con el m\u00e9todo: int add(String input) El par\u00e1metro del m\u00e9todo puede contener 0, 1 o 2 n\u00fameros y devolver\u00e1 su suma (para un string vac\u00edo devolver\u00e1 0). Por ejempo: \"\" o \"1\" o \"1,2\u201d Comieza por un test simple para un string vac\u00edo y luego para 1 y 2 n\u00fameros. Recuerda resolver el problema de la manera m\u00e1s simple posible para que te fuerce a escribir las pruebas que a\u00fan no se te hab\u00edan ocurrido. Recuerda refactorizar despu\u00e9s de conseguir pasar cada test.","title":"Requisito"},{"location":"step1/#desarrollo","text":"","title":"Desarrollo"},{"location":"step1/#empezamos-la-codificacion","text":"Como siempre, en TDD, empezamos creando el test unitario que cubra el primer requisito. Vamos a empezar con la primera parte del requisito y vamos a testear la cadena vac\u00eda. Para ello a\u00f1adimos un test: TestStringCalculator 1 2 3 4 5 6 @Test public void empty_string_return_zero () { StringCalculator calculator = new StringCalculator (); Assert . assertEquals ( 0 , calculator . add ( \"\" )); } Recuerda Recuerda que los nombres de los tests deben ser descriptivos, para que no sea necesario leer el c\u00f3digo del test para saber lo que realiza. Con leer el nombre del m\u00e9todo deber\u00eda ser suficiente para saber lo que hace. Obviamente si ejecutamos el test, obtendremos un test fail en rojo ya que nuestro c\u00f3digo no cumple con lo esperado por el test. El siguiente paso en TDD es realizar la implementaci\u00f3n m\u00ednima que haga funcionar los tests. StringCalculator 1 2 3 4 public int add ( String input ) { return 0 ; } La implementaci\u00f3n m\u00ednima que se me ocurre ahora mismo y que pasar\u00eda todos los tests actuales es esta. Ahora si ejecutamos, obtenemos una ejecuci\u00f3n correcta en verde. El siguiente paso paso en TDD ser\u00eda realizar el Refactoring . Aunque se podr\u00eda aplicar alguna acci\u00f3n, vamos a dejarlo pasar hasta tener algo m\u00e1s de c\u00f3digo, donde ya empecemos a detectar ciertos smells .","title":"Empezamos la codificaci\u00f3n"},{"location":"step1/#segundo-test-unitario","text":"Vamos con el segundo test. En esta ocasi\u00f3n vamos a probar que si la entrada es un n\u00famero debe devolver ese n\u00fameros. De nuevo hacemos el test para probar, fallar\u00e1, e implementaremos el c\u00f3digo m\u00ednimo para que cumpla con todos los tests y dejarlo en un estado correcto en verde. TestStringCalculator 1 2 3 4 5 6 7 8 @Test public void one_number_return_this_number () { StringCalculator calculator = new StringCalculator (); Assert . assertEquals ( 1 , calculator . add ( \"1\" )); Assert . assertEquals ( 2 , calculator . add ( \"2\" )); Assert . assertEquals ( 13 , calculator . add ( \"13\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 public int add ( String input ) { if ( input . equals ( \"\" )) return 0 ; else return Integer . parseInt ( input ); } Ahora que tenemos la aplicaci\u00f3n estable, en verde, y tenemos un poco m\u00e1s de c\u00f3digo podemos empezar a realizar el Refactoring . StringCalculator 1 2 3 4 5 6 7 8 9 public int add ( String input ) { if ( input . equals ( \"\" )) /*(1)*/ return 0 ; else /*(2)*/ return Integer . parseInt ( input ); } StringCalculator-Refactor-1 1 2 3 4 5 6 7 8 public int add ( String input ) { if ( \"\" . equals ( input )) /*(3)*/ return 0 ; /*(3)*/ return Integer . parseInt ( input ); } StringCalculator-Refactor-2 1 2 3 4 5 6 7 8 9 10 11 12 private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; return Integer . parseInt ( input ); } Refactoring (1) Tal y como est\u00e1 escrito, si la entrada input fuera null, en esa l\u00ednea nos saltar\u00eda un NullPointerException . Hay varias formas en las que podr\u00edamos corregirlo, o bien utilizando librer\u00edas de utilidades sobre String como las de ApacheUtils que ya hacen comprobaciones, o bien a\u00f1adiendo una comprobaci\u00f3n previa input != null , o bien simplemente d\u00e1ndole la vuelta al equals. Sabemos que la cadena vac\u00eda nunca va a ser nula, as\u00ed que si le damos la vuelta no puede saltar un NullPointerException . (2) La clausula else la podemos eliminar ya que no aporta nada al c\u00f3digo. Cuando programemos, debemos tener en cuenta que todos los condicionales if , if else y else , obligan al cerebro a tener que recordar cual era la condici\u00f3n anterior e ir acumul\u00e1ndolas. En este caso el else nos obliga a pensar que antes hab\u00eda un if que dec\u00eda si la cadena era vac\u00eda, as\u00ed que en este caso se ejecutar\u00e1 cuando la cadena no sea vac\u00eda. Esto se puede arreglar f\u00e1cil metiendo operaciones de return y simplificando el nivel de los if y else . (3) Tanto la cadena vac\u00eda como el n\u00famero 0 son smells de tipo Magic Number . En este caso est\u00e1 bastante claro que se trata de una entrada vac\u00eda y el resultado cero, pero est\u00e1 bien acostumbrarnos a tener todas esas variables o resultados por defecto en constantes. De nuevo la nomenclatura es importante, el nombre de la constante debe describir para que vamos a utilizar ese valor. No sirve con poner ZERO o EMPTY_STRING porque eso ya lo sabemos al ver el valor. Debemos ponerle un nombre acorde con la funcionalidad de ese valor. Cuando realizamos Refactoring del c\u00f3digo no debemos olvidar que los jUnits tambi\u00e9n forman parte del c\u00f3digo, as\u00ed que tambi\u00e9n son susceptibles de hacerles Refactoring . As\u00ed que vamos a ello: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test public void empty_string_return_zero () { StringCalculator calculator = new StringCalculator (); /*(1)*/ Assert . assertEquals ( 0 , calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { StringCalculator calculator = new StringCalculator (); /*(1)*/ Assert . assertEquals ( 1 , calculator . add ( \"1\" )); Assert . assertEquals ( 2 , calculator . add ( \"2\" )); Assert . assertEquals ( 13 , calculator . add ( \"13\" )); } TestStringCalculator-Refactor-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } Refactoring (1) Existe c\u00f3digo duplicado en los test y tiene pinta de que se va a duplicar m\u00e1s veces, as\u00ed que es una buena pr\u00e1ctica extraer el c\u00f3digo duplicado a una variable o m\u00e9todo externo.","title":"Segundo test unitario"},{"location":"step1/#tercer-test-unitario","text":"Vamos con el tercer y \u00faltimo test de este requisito. En esta ocasi\u00f3n vamos a probar que si la entrada son dos n\u00fameros separados por coma, debe devolver la suma de esos n\u00fameros. De nuevo hacemos el test para probar, fallar\u00e1, e implementaremos el c\u00f3digo m\u00ednimo para que cumpla con todos los tests y dejarlo en un estado correcto en verde. TestStringCalculator 1 2 3 4 5 6 @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( \",\" )) { String aux [] = input . split ( \",\" ); return Integer . parseInt ( aux [ 0 ] ) + Integer . parseInt ( aux [ 1 ] ); } return Integer . parseInt ( input ); } De nuevo, como tenemos estables el c\u00f3digo y los tests funcionando, es hora de hacer Refactoring . StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( \",\" )) { /*(1)*/ String aux [] = input . split ( \",\" ); /*(1)*/ /*(2)*/ return Integer . parseInt ( aux [ 0 ] ) + Integer . parseInt ( aux [ 1 ] ); /*(2)*/ } return Integer . parseInt ( input ); } StringCalculator-Refactor-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); return Integer . parseInt ( numbers [ 0 ] ) + Integer . parseInt ( numbers [ 1 ] ); } return Integer . parseInt ( input ); } Refactoring (1) De nuevo tenemos un Magic Number que podemos extraer a una constante. En este caso la hemos llamado DELIMITER porque encaja bien con la sem\u00e1ntica que se le quiere dar a la coma. (2) Aqu\u00ed el nombre de la variable no es nada descriptivo. Tendemos a ahorrarnos caracteres al escribir nombres de variables y m\u00e9todos, cuando no nos cobran por escribir m\u00e1s, y no penalizamos el rendimiento. Un nombre de variable m\u00e1s correcto podr\u00eda ser numbers , ya que es lo que vamos a almacenar en este vector.","title":"Tercer test unitario"},{"location":"step1/#resultado-final","text":"Llegados a este punto y con estos tests ya tendr\u00edamos cubiertos este primer requisito. Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class StringCalculator { private static final String DELIMITER = \",\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); return Integer . parseInt ( numbers [ 0 ] ) + Integer . parseInt ( numbers [ 1 ] ); } return Integer . parseInt ( input ); } }","title":"Resultado final"},{"location":"step2/","text":"Desarrollo del requisito 2 Requisito Permite al metodo \u201cadd\" manejar cualquier cantidad de n\u00fameros Desarrollo Este requisito es simple, no se puede fraccionar en varios tests, as\u00ed que vamos a implementarlo directamente tanto jUnit como su c\u00f3digo en la aplicaci\u00f3n para que se cumpla el test. TestStringCalculator 1 2 3 4 5 6 7 @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); int a = 0 ; for ( int i = 0 ; i < numbers . length ; i ++ ) { a += Integer . parseInt ( numbers [ i ] ); } return a ; } return Integer . parseInt ( input ); } Poco a poco el c\u00f3digo va creciendo y podemos aplicar m\u00e1s refactors diferentes. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); int a = 0 ; /*(1)*/ for ( int i = 0 ; i < numbers . length ; i ++ ) { /*(1)*/ a += Integer . parseInt ( numbers [ i ] ); /*(1)*/ } /*(1)*/ return a ; /*(1)*/ } return Integer . parseInt ( input ); } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } return Integer . parseInt ( input ); } private int addNumbers ( String numbers [] ) { int a = 0 ; /*(2)*/ for ( int i = 0 ; i < numbers . length ; i ++ ) { a += Integer . parseInt ( numbers [ i ] ); /*(2)*/ } return a ; /*(2)*/ } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { /*(3)*/ String numbers [] = input . split ( DELIMITER ); /*(3)*/ return addNumbers ( numbers ); /*(3)*/ } /*(3)*/ return Integer . parseInt ( input ); /*(3)*/ } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( int i = 0 ; i < numbers . length ; i ++ ) { /*(4)*/ total += Integer . parseInt ( numbers [ i ] ); /*(4)*/ } return total ; } StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } Refactoring (1) El m\u00e9todo empieza a ser muy largo y hace demasiadas cosas (comprobar si es vac\u00edo, comprobar si tiene delimitador, partir la cadena, recorrerla, sumarla). No podemos escribir toda una novela en un solo cap\u00edtulo, debemos empezar a partir el m\u00e9todo. Cuando un m\u00e9todo (o clase) empieza a tener muchas l\u00edneas o empieza a coger demasiadas responsabilidades, debemos separarlo en varios. Lo m\u00e1s f\u00e1cil y r\u00e1pido es coger una de esas responsabilidades, por ejemplo la de sumar los n\u00fameros, y extraerla a un m\u00e9todo privado que ejecute esas operaciones. Importante en este punto darle un nombre correcto al m\u00e9todo que nos indique que es lo que vamos a hacer al invocarlo, addNumbers creo que es bastante descriptivo. (2) Como ya hemos comentado los nombres, de variables o m\u00e9todos, cortos, ocasionan bastantes problemas y dificultades al leerlos, ya que generalemente debes memorizar lo que est\u00e1n almacenando, ya que sem\u00e1nticamente no es posible deducirlo de su nombre. En nuestro caso, la variable a nos sirve para ir acumulando la suma total, podr\u00edamos llamarlo as\u00ed, total o totalSum . (3) En este bloque de c\u00f3digo, sin nos paramos a pensar, tenemos c\u00f3digo duplicado. A veces es dificil de ver este tipo de smell , pero si nos fijamos bien, vemos que aunque el c\u00f3digo no sea igual que el otro, funcionalmente hacen lo mismo. En nuestro caso, si troceamos el input y resulta que no ten\u00eda ning\u00fan delimitador, el m\u00e9todo split nos va a devolver un array con un \u00fanico texto. Si sumamos ese \u00fanico texto, obtenemos el mismo resultado que haciendo un parseInt de la l\u00ednea 11. Es decir, que nos podemos ahorrar el if y la duplicidad. (4) Ya por \u00faltimo, y aunque no es un smell como tal. Siempre que podamos debemos simplificar la codificaci\u00f3n del algoritmo. En este caso, ya que no vamos a utilizar el \u00edndice i para nada, se podr\u00eda sustituir el for , por un forEach o incluso utilizar las funciones de Streams . Resultado final Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class StringCalculator { private static final String DELIMITER = \",\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"R2. Suma varios n\u00fameros"},{"location":"step2/#desarrollo-del-requisito-2","text":"","title":"Desarrollo del requisito 2"},{"location":"step2/#requisito","text":"Permite al metodo \u201cadd\" manejar cualquier cantidad de n\u00fameros","title":"Requisito"},{"location":"step2/#desarrollo","text":"Este requisito es simple, no se puede fraccionar en varios tests, as\u00ed que vamos a implementarlo directamente tanto jUnit como su c\u00f3digo en la aplicaci\u00f3n para que se cumpla el test. TestStringCalculator 1 2 3 4 5 6 7 @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); int a = 0 ; for ( int i = 0 ; i < numbers . length ; i ++ ) { a += Integer . parseInt ( numbers [ i ] ); } return a ; } return Integer . parseInt ( input ); } Poco a poco el c\u00f3digo va creciendo y podemos aplicar m\u00e1s refactors diferentes. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); int a = 0 ; /*(1)*/ for ( int i = 0 ; i < numbers . length ; i ++ ) { /*(1)*/ a += Integer . parseInt ( numbers [ i ] ); /*(1)*/ } /*(1)*/ return a ; /*(1)*/ } return Integer . parseInt ( input ); } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } return Integer . parseInt ( input ); } private int addNumbers ( String numbers [] ) { int a = 0 ; /*(2)*/ for ( int i = 0 ; i < numbers . length ; i ++ ) { a += Integer . parseInt ( numbers [ i ] ); /*(2)*/ } return a ; /*(2)*/ } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; if ( input . contains ( DELIMITER )) { /*(3)*/ String numbers [] = input . split ( DELIMITER ); /*(3)*/ return addNumbers ( numbers ); /*(3)*/ } /*(3)*/ return Integer . parseInt ( input ); /*(3)*/ } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( int i = 0 ; i < numbers . length ; i ++ ) { /*(4)*/ total += Integer . parseInt ( numbers [ i ] ); /*(4)*/ } return total ; } StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } Refactoring (1) El m\u00e9todo empieza a ser muy largo y hace demasiadas cosas (comprobar si es vac\u00edo, comprobar si tiene delimitador, partir la cadena, recorrerla, sumarla). No podemos escribir toda una novela en un solo cap\u00edtulo, debemos empezar a partir el m\u00e9todo. Cuando un m\u00e9todo (o clase) empieza a tener muchas l\u00edneas o empieza a coger demasiadas responsabilidades, debemos separarlo en varios. Lo m\u00e1s f\u00e1cil y r\u00e1pido es coger una de esas responsabilidades, por ejemplo la de sumar los n\u00fameros, y extraerla a un m\u00e9todo privado que ejecute esas operaciones. Importante en este punto darle un nombre correcto al m\u00e9todo que nos indique que es lo que vamos a hacer al invocarlo, addNumbers creo que es bastante descriptivo. (2) Como ya hemos comentado los nombres, de variables o m\u00e9todos, cortos, ocasionan bastantes problemas y dificultades al leerlos, ya que generalemente debes memorizar lo que est\u00e1n almacenando, ya que sem\u00e1nticamente no es posible deducirlo de su nombre. En nuestro caso, la variable a nos sirve para ir acumulando la suma total, podr\u00edamos llamarlo as\u00ed, total o totalSum . (3) En este bloque de c\u00f3digo, sin nos paramos a pensar, tenemos c\u00f3digo duplicado. A veces es dificil de ver este tipo de smell , pero si nos fijamos bien, vemos que aunque el c\u00f3digo no sea igual que el otro, funcionalmente hacen lo mismo. En nuestro caso, si troceamos el input y resulta que no ten\u00eda ning\u00fan delimitador, el m\u00e9todo split nos va a devolver un array con un \u00fanico texto. Si sumamos ese \u00fanico texto, obtenemos el mismo resultado que haciendo un parseInt de la l\u00ednea 11. Es decir, que nos podemos ahorrar el if y la duplicidad. (4) Ya por \u00faltimo, y aunque no es un smell como tal. Siempre que podamos debemos simplificar la codificaci\u00f3n del algoritmo. En este caso, ya que no vamos a utilizar el \u00edndice i para nada, se podr\u00eda sustituir el for , por un forEach o incluso utilizar las funciones de Streams .","title":"Desarrollo"},{"location":"step2/#resultado-final","text":"Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class StringCalculator { private static final String DELIMITER = \",\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final"},{"location":"step3/","text":"Desarrollo del requisito 3 Requisito Permite al m\u00e9todo \"add\" manejar saltos de l\u00ednea entre n\u00fameros en lugar de usar comas. La siguiente entrada es correcta: \"1\\n2,3\" (el resultado ser\u00e1 6) La siguiente entrada NO es correcta: \"1,\\n\" (no hace falta que la pruebes, es simplemente para clarificar) Desarrollo Este requisito, es muy sencillo de implementar si conocemos un poco la funcionalidad de split . TestStringCalculator 1 2 3 4 5 6 @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } StringCalculator 1 private static final String DELIMITER = \",|\\n\" ; Regex Recuerda que en Java existen muchos m\u00e9todos que operan sobre cadenas de texto y que aceptan expresiones regulares. Este tipo de expresiones son realmente potentes y muy \u00fatiles para simplificar operaciones. Revisa la p\u00e1gina de Baeldung - Expresiones Regulares , para profundizar m\u00e1s en este tema. Con este cambio, no hace falta ningun Refactoring . As\u00ed que dejaremos el c\u00f3digo tal cual lo tenemos. Resultado final Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class StringCalculator { private static final String DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"R3. Saltos de l\u00ednea"},{"location":"step3/#desarrollo-del-requisito-3","text":"","title":"Desarrollo del requisito 3"},{"location":"step3/#requisito","text":"Permite al m\u00e9todo \"add\" manejar saltos de l\u00ednea entre n\u00fameros en lugar de usar comas. La siguiente entrada es correcta: \"1\\n2,3\" (el resultado ser\u00e1 6) La siguiente entrada NO es correcta: \"1,\\n\" (no hace falta que la pruebes, es simplemente para clarificar)","title":"Requisito"},{"location":"step3/#desarrollo","text":"Este requisito, es muy sencillo de implementar si conocemos un poco la funcionalidad de split . TestStringCalculator 1 2 3 4 5 6 @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } StringCalculator 1 private static final String DELIMITER = \",|\\n\" ; Regex Recuerda que en Java existen muchos m\u00e9todos que operan sobre cadenas de texto y que aceptan expresiones regulares. Este tipo de expresiones son realmente potentes y muy \u00fatiles para simplificar operaciones. Revisa la p\u00e1gina de Baeldung - Expresiones Regulares , para profundizar m\u00e1s en este tema. Con este cambio, no hace falta ningun Refactoring . As\u00ed que dejaremos el c\u00f3digo tal cual lo tenemos.","title":"Desarrollo"},{"location":"step3/#resultado-final","text":"Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class StringCalculator { private static final String DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] = input . split ( DELIMITER ); return addNumbers ( numbers ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final"},{"location":"step4/","text":"Desarrollo del requisito 4 Requisito Soporta diferentes delimitadores Para cambiar un delimitador, el comienzo del string debe contener una l\u00ednea separada que sea como esta: \"//[delimitador]\\n[n\u00fameros...]\". Por ejemplo: \"//;\\n1;2\" debe dar como resultado 3 donde el delimitador por defecto es \";\". La primera l\u00ednea es opcional. Todos los escenarios existentes hasta ahora, deben estar soportados. Desarrollo Este requisito es m\u00e1s complejo que el anterior. Tenemos que comprobar si la cadena de entrada tiene el texto // y en funci\u00f3n de si viene o no, utilizar el delimitador custom o el delimitador por defecto. TestStringCalculator 1 2 3 4 5 6 @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; if ( input . startsWith ( \"//\" )) { int endIndex = input . indexOf ( \"\\n\" ); String customDelimiter = input . substring ( 2 , endIndex ); input = input . substring ( endIndex + 1 ); numbers = input . split ( customDelimiter ); } else { numbers = input . split ( DELIMITER ); } return addNumbers ( numbers ); } De nuevo el c\u00f3digo es un poco confuso, as\u00ed que vamos a intentar mejorarlo un poco aplicando algo de Refactoring . StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; if ( input . startsWith ( \"//\" )) { int endIndex = input . indexOf ( \"\\n\" ); String customDelimiter = input . substring ( 2 , endIndex ); /*(1)*/ input = input . substring ( endIndex + 1 ); numbers = input . split ( customDelimiter ); /*(2)*/ } else { numbers = input . split ( DELIMITER ); /*(1) (2)*/ } return addNumbers ( numbers ); } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private static final String DEFAULT_DELIMITER = \",|\\n\" ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( \"//\" )) { /*(3)*/ int endIndex = input . indexOf ( \"\\n\" ); /*(3)*/ delimiter = input . substring ( 2 , endIndex ); /*(4)*/ input = input . substring ( endIndex + 1 ); /*(4)*/ } numbers = input . split ( delimiter ); return addNumbers ( numbers ); } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } numbers = input . split ( delimiter ); return addNumbers ( numbers ); } Refactoring (1) A veces, a medida que vamos a\u00f1adiendo c\u00f3digo le vamos cambiando el sentido o el contexto a las variables o a los m\u00e9todos. En este caso, la constante DELIMITER ya no tiene mucho sentido que se llame as\u00ed, en realidad deber\u00eda llamarse DEFAULT_DELIMITER . (2) Volvemos a tener c\u00f3digo duplicado, que podr\u00eda solucionarse muy f\u00e1cilmente eliminando toda la clausula else y sacando fuera del if el m\u00e9todo de split . (3) Si nos fijamos bien, los textos, son smells muy f\u00e1ciles de detectar, al igual que los n\u00fameros. Se trata del t\u00edpico Magic Number . \u00bfQue significa // ? \u00bfPor qu\u00e9 es // y no es %% ?. Si le damos nombre a esos valores, quedar\u00e1 m\u00e1s claro. (4) Lo mismo pasa con los n\u00fameros, volvemos a tener Magic Number . \u00bfPor qu\u00e9 le sumamos 2 y no 3 o 4?. Cambiandolo por algo sem\u00e1ntico queda mucho m\u00e1s claro. Llegamos a este punto, parece que ya no podemos mejorar mucho m\u00e1s el c\u00f3digo pero, a menudo, para intentar mejorar el c\u00f3digo hay que meter peque\u00f1os smells . En el ejemplo que estamos haciendo, podemos introducir un poco de duplicado de c\u00f3digo, para poder aplicar otro tipo de Refactor que nos ayude a aumentar la legibilidad. Todo el bloque se\u00f1alado en el Refactor-2 se podr\u00eda desdoblar en algo similar a esto: StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = DEFAULT_DELIMITER ; /*(5)*/ if ( input . startsWith ( START_DELIMITER_TOKEN )) { /*(5)*/ int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); /*(5)*/ delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); /*(5)*/ } /*(5)*/ if ( input . startsWith ( START_DELIMITER_TOKEN )) { /*(6)*/ int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); /*(6)*/ input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); /*(6)*/ } /*(6)*/ String numbers [] = input . split ( delimiter ); /*(6)*/ return addNumbers ( numbers ); } StringCalculator-Ref4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); return addNumbers ( numbers ); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } Refactoring (5) Ahora que ya lo tenemos desdoblado, vemos claramente que el m\u00e9todo hace demasiadas cosas. Podr\u00edamos extraer el bloque de c\u00f3digo a un m\u00e9todo que nos indicara claramente lo que hace, por ejemplo extractDelimiter . (6) El mismo caso que el anterior, le podr\u00edamos dar el nombre extractNumbers . Despu\u00e9s del Refactor-4 volvemos a tener el c\u00f3digo mucho m\u00e1s legible, de hecho se ve claramente lo que el m\u00e9todo hace: extrae el delimitador, extrae los n\u00fameros con ese delimitador y realiza la suma de esos n\u00fameros. Muy f\u00e1cil de leer. Si queremos ver el detalle de cada m\u00e9todo, pues ya nos ir\u00edamos al m\u00e9todo concreto y lo leer\u00edamos, que aunque en esencia es lo mismo que ten\u00edamos antes todo junto, en este caso, al leerlo, tenemos el contexto acotado a ese m\u00e9todo y el cerebro no trabaja tanto intentando recordar. Resultado final Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class StringCalculator { private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); return addNumbers ( numbers ); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"R4. Varios delimitadores"},{"location":"step4/#desarrollo-del-requisito-4","text":"","title":"Desarrollo del requisito 4"},{"location":"step4/#requisito","text":"Soporta diferentes delimitadores Para cambiar un delimitador, el comienzo del string debe contener una l\u00ednea separada que sea como esta: \"//[delimitador]\\n[n\u00fameros...]\". Por ejemplo: \"//;\\n1;2\" debe dar como resultado 3 donde el delimitador por defecto es \";\". La primera l\u00ednea es opcional. Todos los escenarios existentes hasta ahora, deben estar soportados.","title":"Requisito"},{"location":"step4/#desarrollo","text":"Este requisito es m\u00e1s complejo que el anterior. Tenemos que comprobar si la cadena de entrada tiene el texto // y en funci\u00f3n de si viene o no, utilizar el delimitador custom o el delimitador por defecto. TestStringCalculator 1 2 3 4 5 6 @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; if ( input . startsWith ( \"//\" )) { int endIndex = input . indexOf ( \"\\n\" ); String customDelimiter = input . substring ( 2 , endIndex ); input = input . substring ( endIndex + 1 ); numbers = input . split ( customDelimiter ); } else { numbers = input . split ( DELIMITER ); } return addNumbers ( numbers ); } De nuevo el c\u00f3digo es un poco confuso, as\u00ed que vamos a intentar mejorarlo un poco aplicando algo de Refactoring . StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; if ( input . startsWith ( \"//\" )) { int endIndex = input . indexOf ( \"\\n\" ); String customDelimiter = input . substring ( 2 , endIndex ); /*(1)*/ input = input . substring ( endIndex + 1 ); numbers = input . split ( customDelimiter ); /*(2)*/ } else { numbers = input . split ( DELIMITER ); /*(1) (2)*/ } return addNumbers ( numbers ); } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private static final String DEFAULT_DELIMITER = \",|\\n\" ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( \"//\" )) { /*(3)*/ int endIndex = input . indexOf ( \"\\n\" ); /*(3)*/ delimiter = input . substring ( 2 , endIndex ); /*(4)*/ input = input . substring ( endIndex + 1 ); /*(4)*/ } numbers = input . split ( delimiter ); return addNumbers ( numbers ); } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String numbers [] ; String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } numbers = input . split ( delimiter ); return addNumbers ( numbers ); } Refactoring (1) A veces, a medida que vamos a\u00f1adiendo c\u00f3digo le vamos cambiando el sentido o el contexto a las variables o a los m\u00e9todos. En este caso, la constante DELIMITER ya no tiene mucho sentido que se llame as\u00ed, en realidad deber\u00eda llamarse DEFAULT_DELIMITER . (2) Volvemos a tener c\u00f3digo duplicado, que podr\u00eda solucionarse muy f\u00e1cilmente eliminando toda la clausula else y sacando fuera del if el m\u00e9todo de split . (3) Si nos fijamos bien, los textos, son smells muy f\u00e1ciles de detectar, al igual que los n\u00fameros. Se trata del t\u00edpico Magic Number . \u00bfQue significa // ? \u00bfPor qu\u00e9 es // y no es %% ?. Si le damos nombre a esos valores, quedar\u00e1 m\u00e1s claro. (4) Lo mismo pasa con los n\u00fameros, volvemos a tener Magic Number . \u00bfPor qu\u00e9 le sumamos 2 y no 3 o 4?. Cambiandolo por algo sem\u00e1ntico queda mucho m\u00e1s claro. Llegamos a este punto, parece que ya no podemos mejorar mucho m\u00e1s el c\u00f3digo pero, a menudo, para intentar mejorar el c\u00f3digo hay que meter peque\u00f1os smells . En el ejemplo que estamos haciendo, podemos introducir un poco de duplicado de c\u00f3digo, para poder aplicar otro tipo de Refactor que nos ayude a aumentar la legibilidad. Todo el bloque se\u00f1alado en el Refactor-2 se podr\u00eda desdoblar en algo similar a esto: StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = DEFAULT_DELIMITER ; /*(5)*/ if ( input . startsWith ( START_DELIMITER_TOKEN )) { /*(5)*/ int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); /*(5)*/ delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); /*(5)*/ } /*(5)*/ if ( input . startsWith ( START_DELIMITER_TOKEN )) { /*(6)*/ int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); /*(6)*/ input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); /*(6)*/ } /*(6)*/ String numbers [] = input . split ( delimiter ); /*(6)*/ return addNumbers ( numbers ); } StringCalculator-Ref4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); return addNumbers ( numbers ); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } Refactoring (5) Ahora que ya lo tenemos desdoblado, vemos claramente que el m\u00e9todo hace demasiadas cosas. Podr\u00edamos extraer el bloque de c\u00f3digo a un m\u00e9todo que nos indicara claramente lo que hace, por ejemplo extractDelimiter . (6) El mismo caso que el anterior, le podr\u00edamos dar el nombre extractNumbers . Despu\u00e9s del Refactor-4 volvemos a tener el c\u00f3digo mucho m\u00e1s legible, de hecho se ve claramente lo que el m\u00e9todo hace: extrae el delimitador, extrae los n\u00fameros con ese delimitador y realiza la suma de esos n\u00fameros. Muy f\u00e1cil de leer. Si queremos ver el detalle de cada m\u00e9todo, pues ya nos ir\u00edamos al m\u00e9todo concreto y lo leer\u00edamos, que aunque en esencia es lo mismo que ten\u00edamos antes todo junto, en este caso, al leerlo, tenemos el contexto acotado a ese m\u00e9todo y el cerebro no trabaja tanto intentando recordar.","title":"Desarrollo"},{"location":"step4/#resultado-final","text":"Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 public class TestStringCalculator { private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class StringCalculator { private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); return addNumbers ( numbers ); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final"},{"location":"step5/","text":"Desarrollo del requisito 5 Requisito Llamar al m\u00e9todo \u201cadd\" con n\u00fameros negativos deber\u00e1 lanzar una excepci\u00f3n con el texto \"negativos no soportados\" y el n\u00famero negativo que ha sido pasado. Si hay m\u00faltiples n\u00fameros negativos, muestra todos ellos en el mensaje de la excepci\u00f3n. Desarrollo Cuando queremos testear que un m\u00e9todo nos devuelve una excepci\u00f3n, deber\u00edamos crearnos una @Rule exception con el valor o mensaje que queremos capturar en el test, en lugar de utilizar los Asserts , como ven\u00edamos haciendo hasta ahora. TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Rule public final ExpectedException exception = ExpectedException . none (); @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); List < Integer > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber < 0 ) negativeNumbers . add ( parsedNumber ); } if ( negativeNumbers . size () > 0 ) { StringBuilder sb = new StringBuilder (); for ( Integer number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); } return addNumbers ( numbers ); } He decidido (como una posible soluci\u00f3n entre muchas), hacer una comprobaci\u00f3n previa a la suma que compare los n\u00fameros y si encuentra alg\u00fan negativo devuelva una excepci\u00f3n. Con este c\u00f3digo vuelven a aparecer varios smells que podemos Refactorizar de forma sencilla. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); List < Integer > negativeNumbers = new ArrayList <> (); /*(1)*/ for ( String number : numbers ) { /*(1)*/ int parsedNumber = Integer . parseInt ( number ); /*(1)*/ if ( parsedNumber < 0 ) /*(1)*/ negativeNumbers . add ( parsedNumber ); /*(1)*/ } /*(1)*/ if ( negativeNumbers . size () > 0 ) { /*(1)*/ StringBuilder sb = new StringBuilder (); /*(1)*/ for ( Integer number : negativeNumbers ) { /*(1)*/ sb . append ( number ); /*(1)*/ sb . append ( \",\" ); /*(1)*/ } /*(1)*/ sb . deleteCharAt ( sb . length () - 1 ); /*(1)*/ throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); /*(1)*/ } /*(1)*/ return addNumbers ( numbers ); } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < Integer > negativeNumbers = new ArrayList <> (); /*(2)*/ for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); /*(2)*/ if ( parsedNumber < 0 ) /*(2)*/ negativeNumbers . add ( parsedNumber ); } if ( negativeNumbers . size () > 0 ) { /*(3)*/ StringBuilder sb = new StringBuilder (); for ( Integer number : negativeNumbers ) { /*(2)*/ sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); } /*(3)*/ } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); /*(4)*/ for ( String number : numbers ) { /*(4)*/ if ( isNegative ( number )) /*(4)*/ negativeNumbers . add ( number ); /*(4)*/ } /*(4)*/ if ( negativeNumbers . isEmpty ()) return ; StringBuilder sb = new StringBuilder (); /*(5)*/ for ( String number : negativeNumbers ) { /*(5)*/ sb . append ( number ); /*(5)*/ sb . append ( \",\" ); /*(5)*/ } /*(5)*/ sb . deleteCharAt ( sb . length () - 1 ); /*(5)*/ throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( Integer . parseInt ( number ) < 0 ) negativeNumbers . add ( number ); } return negativeNumbers ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } Refactoring (1) Extract Method , vemos que el m\u00e9todo add es demasiado largo y hace muchas cosas, as\u00ed que mejor extraemos todo lo que acabamos de implementar a un m\u00e9todo nuevo que se llame checkNegativeNumbers . (2) Vemos que la comparaci\u00f3n es sencilla, pero aun podr\u00edamos ayudar m\u00e1s a su comprensi\u00f3n. Adem\u00e1s, podemos aprovechar para minimizarlo todo si en vez de un Array de Integers lo cambiamos a un Array de Strings. Vamos a crear un m\u00e9todo que nos diga si un n\u00famero es negativo o no isNegative , eso facilitar\u00e1 la lectura. (3) Es un bloque if complejo que si le damos la vuelta a la comparaci\u00f3n, se hace mucho m\u00e1s sencillo de entender y de memorizar. (4) Extract Method , igual que en el primer punto, se puede extraer la funcionalidad para darle mejor sem\u00e1ntica al m\u00e9todo. Haremos un m\u00e9todo llamado getNegativeNumbers . (5) Extract Method , igual que el punto anterior, extraeremos un m\u00e9todo llamado convertListToString . Resultado final En este punto deber\u00edamos tener el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 public class StringCalculator { private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"R5. No n\u00fameros negativos"},{"location":"step5/#desarrollo-del-requisito-5","text":"","title":"Desarrollo del requisito 5"},{"location":"step5/#requisito","text":"Llamar al m\u00e9todo \u201cadd\" con n\u00fameros negativos deber\u00e1 lanzar una excepci\u00f3n con el texto \"negativos no soportados\" y el n\u00famero negativo que ha sido pasado. Si hay m\u00faltiples n\u00fameros negativos, muestra todos ellos en el mensaje de la excepci\u00f3n.","title":"Requisito"},{"location":"step5/#desarrollo","text":"Cuando queremos testear que un m\u00e9todo nos devuelve una excepci\u00f3n, deber\u00edamos crearnos una @Rule exception con el valor o mensaje que queremos capturar en el test, en lugar de utilizar los Asserts , como ven\u00edamos haciendo hasta ahora. TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Rule public final ExpectedException exception = ExpectedException . none (); @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); List < Integer > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber < 0 ) negativeNumbers . add ( parsedNumber ); } if ( negativeNumbers . size () > 0 ) { StringBuilder sb = new StringBuilder (); for ( Integer number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); } return addNumbers ( numbers ); } He decidido (como una posible soluci\u00f3n entre muchas), hacer una comprobaci\u00f3n previa a la suma que compare los n\u00fameros y si encuentra alg\u00fan negativo devuelva una excepci\u00f3n. Con este c\u00f3digo vuelven a aparecer varios smells que podemos Refactorizar de forma sencilla. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); List < Integer > negativeNumbers = new ArrayList <> (); /*(1)*/ for ( String number : numbers ) { /*(1)*/ int parsedNumber = Integer . parseInt ( number ); /*(1)*/ if ( parsedNumber < 0 ) /*(1)*/ negativeNumbers . add ( parsedNumber ); /*(1)*/ } /*(1)*/ if ( negativeNumbers . size () > 0 ) { /*(1)*/ StringBuilder sb = new StringBuilder (); /*(1)*/ for ( Integer number : negativeNumbers ) { /*(1)*/ sb . append ( number ); /*(1)*/ sb . append ( \",\" ); /*(1)*/ } /*(1)*/ sb . deleteCharAt ( sb . length () - 1 ); /*(1)*/ throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); /*(1)*/ } /*(1)*/ return addNumbers ( numbers ); } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < Integer > negativeNumbers = new ArrayList <> (); /*(2)*/ for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); /*(2)*/ if ( parsedNumber < 0 ) /*(2)*/ negativeNumbers . add ( parsedNumber ); } if ( negativeNumbers . size () > 0 ) { /*(3)*/ StringBuilder sb = new StringBuilder (); for ( Integer number : negativeNumbers ) { /*(2)*/ sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); } /*(3)*/ } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); /*(4)*/ for ( String number : numbers ) { /*(4)*/ if ( isNegative ( number )) /*(4)*/ negativeNumbers . add ( number ); /*(4)*/ } /*(4)*/ if ( negativeNumbers . isEmpty ()) return ; StringBuilder sb = new StringBuilder (); /*(5)*/ for ( String number : negativeNumbers ) { /*(5)*/ sb . append ( number ); /*(5)*/ sb . append ( \",\" ); /*(5)*/ } /*(5)*/ sb . deleteCharAt ( sb . length () - 1 ); /*(5)*/ throw new RuntimeException ( \"negativos no soportados: \" + sb . toString ()); } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( Integer . parseInt ( number ) < 0 ) negativeNumbers . add ( number ); } return negativeNumbers ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } Refactoring (1) Extract Method , vemos que el m\u00e9todo add es demasiado largo y hace muchas cosas, as\u00ed que mejor extraemos todo lo que acabamos de implementar a un m\u00e9todo nuevo que se llame checkNegativeNumbers . (2) Vemos que la comparaci\u00f3n es sencilla, pero aun podr\u00edamos ayudar m\u00e1s a su comprensi\u00f3n. Adem\u00e1s, podemos aprovechar para minimizarlo todo si en vez de un Array de Integers lo cambiamos a un Array de Strings. Vamos a crear un m\u00e9todo que nos diga si un n\u00famero es negativo o no isNegative , eso facilitar\u00e1 la lectura. (3) Es un bloque if complejo que si le damos la vuelta a la comparaci\u00f3n, se hace mucho m\u00e1s sencillo de entender y de memorizar. (4) Extract Method , igual que en el primer punto, se puede extraer la funcionalidad para darle mejor sem\u00e1ntica al m\u00e9todo. Haremos un m\u00e9todo llamado getNegativeNumbers . (5) Extract Method , igual que el punto anterior, extraeremos un m\u00e9todo llamado convertListToString .","title":"Desarrollo"},{"location":"step5/#resultado-final","text":"En este punto deber\u00edamos tener el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 public class StringCalculator { private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final"},{"location":"step6/","text":"Desarrollo del requisito 6 Requisito Los numeros mayores de 1000 deben ser ignorados. Por ejemplo \"2,1001\" dar\u00e1 como resultado 2.\" Desarrollo Ahora tenemos el c\u00f3digo tan estructura que hacer un cambio es muy sencillo. Simplemente iremos al m\u00e9todo que realiza la suma de n\u00fameros ( addNumbers ) y a\u00f1adiremos esa comprobaci\u00f3n. Pero antes de eso, hay que implementar un test para este requisito. TestStringCalculator 1 2 3 4 5 @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= 1000 ) total += Integer . parseInt ( number ); } return total ; } Esta implementaci\u00f3n, admite un peque\u00f1o Refactor : StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= 1000 ) /*(1)*/ total += Integer . parseInt ( number ); } return total ; } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } Refactoring (1) Extract Constant , el n\u00famero 1000 es un Magic Number de libro. \u00bfQue significado tiene 1000? Alguien que no se haya le\u00eddo los requisitos se preguntar\u00e1 \u00bfpor qu\u00e9 est\u00e1 ese n\u00famero y no otro?. Mejor si le damos un contexto, una sem\u00e1ntica a ese n\u00famero. Resultado final Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public class StringCalculator { private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"R6. No n\u00fameros mayores 1000"},{"location":"step6/#desarrollo-del-requisito-6","text":"","title":"Desarrollo del requisito 6"},{"location":"step6/#requisito","text":"Los numeros mayores de 1000 deben ser ignorados. Por ejemplo \"2,1001\" dar\u00e1 como resultado 2.\"","title":"Requisito"},{"location":"step6/#desarrollo","text":"Ahora tenemos el c\u00f3digo tan estructura que hacer un cambio es muy sencillo. Simplemente iremos al m\u00e9todo que realiza la suma de n\u00fameros ( addNumbers ) y a\u00f1adiremos esa comprobaci\u00f3n. Pero antes de eso, hay que implementar un test para este requisito. TestStringCalculator 1 2 3 4 5 @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= 1000 ) total += Integer . parseInt ( number ); } return total ; } Esta implementaci\u00f3n, admite un peque\u00f1o Refactor : StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= 1000 ) /*(1)*/ total += Integer . parseInt ( number ); } return total ; } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } Refactoring (1) Extract Constant , el n\u00famero 1000 es un Magic Number de libro. \u00bfQue significado tiene 1000? Alguien que no se haya le\u00eddo los requisitos se preguntar\u00e1 \u00bfpor qu\u00e9 est\u00e1 ese n\u00famero y no otro?. Mejor si le damos un contexto, una sem\u00e1ntica a ese n\u00famero.","title":"Desarrollo"},{"location":"step6/#resultado-final","text":"Al finalizar obtenemos el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public class StringCalculator { private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); } return delimiter ; } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final"},{"location":"step7/","text":"Desarrollo del requisito 7 Requisito Los delimitadores pueden ser de cualquier longitud con el siguiente formato: '//[delimiter]\\n'. Por ejemplo: \"//[;;;]\\n1;;;2;;;3\" debe dar como resultado 6. Desarrollo De nuevo sabemos donde tenemos que modificar. Tenemos un m\u00e9todo concreto que extrae el delimitador, as\u00ed que debemos modificar el c\u00f3digo de ese m\u00e9todo para ajustarlo al nuevo requisito. TestStringCalculator 1 2 3 4 5 @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( delimiter . startsWith ( \"[\" ) && delimiter . endsWith ( \"]\" )) { delimiter = delimiter . substring ( 1 , delimiter . length () - 1 ); } } return delimiter ; } No me siento del todo c\u00f3modo con este c\u00f3digo, veo algunas cadenas de texto que podr\u00eda extraer ( MagicNumber ), veo una condici\u00f3n doble con un && que a veces resulta dificil de leer y veo un if dentro de otro if . Como me ha costado poco tiempo implementar el cambio, me gustar\u00eda darle una vuelta a ver si lo puedo simplificar. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( delimiter . startsWith ( \"[\" ) && delimiter . endsWith ( \"]\" )) { /*(1)(2)*/ delimiter = delimiter . substring ( 1 , delimiter . length () - 1 ); /*(3)*/ } } return delimiter ; } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; /*(4)*/ if ( input . startsWith ( START_DELIMITER_TOKEN )) { /*(4)*/ int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } } /*(4)*/ return delimiter ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private String extractDelimiter ( String input ) { if ( input . startsWith ( START_DELIMITER_TOKEN ) == false ) /*(5)*/ return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } return delimiter ; } StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } Refactoring (1) Extract Constant , vamos a refactorizar los MagicNumber y vamos a crear constantes que nos indiquen que significa [ y ] . Por ejemplo les llamaremos START_LONG_DELIMITER_TOKEN y END_LONG_DELIMITER_TOKEN . (2) Extract Method , adem\u00e1s, vamos a reducir la complejidad de las condiciones dobles extrayendo la comparaci\u00f3n a un m\u00e9todo con un nombre m\u00e1s f\u00e1cil de entender isLongDelimiter . (3) Tambi\u00e9n utilizaremos el refactor que hemos hecho en el punto 1, para darle m\u00e1s legibilidad a los n\u00fameros 1 que tenemos en el c\u00f3digo y no sabemos muy bien de donde vienen. (4) Como tenemos dos if anidados, cuando llegamos al segundo tenemos que ir acumulando condiciones en el cerebro. El ser humano es perezoso por naturaleza y todo lo que requiera un gasto energ\u00e9tico va a intentar eludirlo, as\u00ed que facilit\u00e9mosle la faena. En este caso en concreto podemos invertir el significado del if , ya que seg\u00fan parece si tiene el token de delimitador \"custom\" hace muchas cosas, y si no lo tiene no hace nada. Pues d\u00e9mosle la vuelta al if y nos evitamos el anidado. (5) Extract Method vamos a reducir la complejidad de la condici\u00f3n. Podr\u00edamos utilizar el operador \"bang\" \u00b4(!)\u00b4 para negar la condici\u00f3n. La verdad es que hay mucho debate en torno a si es legible o no ese operador, yo prefiero utilizarlo lo menos posible ya que muchas veces dificulta bastante la lectura, sobre todo cuando se trata de comparaciones m\u00e1s complejas. Prefiero extraer a un m\u00e9todo la comparaci\u00f3n y darle un valor sem\u00e1ntico al nombre del m\u00e9todo, por ejemplo isDefaultDelimiter . Ahora el c\u00f3digo queda m\u00e1s claro, ya no existe esa animaci\u00f3n de if y las condiciones son m\u00e1s f\u00e1ciles de leer. Resultado final Deber\u00edamos tener el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 public class StringCalculator { private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"R7. Delimitadores largos"},{"location":"step7/#desarrollo-del-requisito-7","text":"","title":"Desarrollo del requisito 7"},{"location":"step7/#requisito","text":"Los delimitadores pueden ser de cualquier longitud con el siguiente formato: '//[delimiter]\\n'. Por ejemplo: \"//[;;;]\\n1;;;2;;;3\" debe dar como resultado 6.","title":"Requisito"},{"location":"step7/#desarrollo","text":"De nuevo sabemos donde tenemos que modificar. Tenemos un m\u00e9todo concreto que extrae el delimitador, as\u00ed que debemos modificar el c\u00f3digo de ese m\u00e9todo para ajustarlo al nuevo requisito. TestStringCalculator 1 2 3 4 5 @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( delimiter . startsWith ( \"[\" ) && delimiter . endsWith ( \"]\" )) { delimiter = delimiter . substring ( 1 , delimiter . length () - 1 ); } } return delimiter ; } No me siento del todo c\u00f3modo con este c\u00f3digo, veo algunas cadenas de texto que podr\u00eda extraer ( MagicNumber ), veo una condici\u00f3n doble con un && que a veces resulta dificil de leer y veo un if dentro de otro if . Como me ha costado poco tiempo implementar el cambio, me gustar\u00eda darle una vuelta a ver si lo puedo simplificar. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( delimiter . startsWith ( \"[\" ) && delimiter . endsWith ( \"]\" )) { /*(1)(2)*/ delimiter = delimiter . substring ( 1 , delimiter . length () - 1 ); /*(3)*/ } } return delimiter ; } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private String extractDelimiter ( String input ) { String delimiter = DEFAULT_DELIMITER ; /*(4)*/ if ( input . startsWith ( START_DELIMITER_TOKEN )) { /*(4)*/ int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } } /*(4)*/ return delimiter ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private String extractDelimiter ( String input ) { if ( input . startsWith ( START_DELIMITER_TOKEN ) == false ) /*(5)*/ return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } return delimiter ; } StringCalculator-Ref3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } Refactoring (1) Extract Constant , vamos a refactorizar los MagicNumber y vamos a crear constantes que nos indiquen que significa [ y ] . Por ejemplo les llamaremos START_LONG_DELIMITER_TOKEN y END_LONG_DELIMITER_TOKEN . (2) Extract Method , adem\u00e1s, vamos a reducir la complejidad de las condiciones dobles extrayendo la comparaci\u00f3n a un m\u00e9todo con un nombre m\u00e1s f\u00e1cil de entender isLongDelimiter . (3) Tambi\u00e9n utilizaremos el refactor que hemos hecho en el punto 1, para darle m\u00e1s legibilidad a los n\u00fameros 1 que tenemos en el c\u00f3digo y no sabemos muy bien de donde vienen. (4) Como tenemos dos if anidados, cuando llegamos al segundo tenemos que ir acumulando condiciones en el cerebro. El ser humano es perezoso por naturaleza y todo lo que requiera un gasto energ\u00e9tico va a intentar eludirlo, as\u00ed que facilit\u00e9mosle la faena. En este caso en concreto podemos invertir el significado del if , ya que seg\u00fan parece si tiene el token de delimitador \"custom\" hace muchas cosas, y si no lo tiene no hace nada. Pues d\u00e9mosle la vuelta al if y nos evitamos el anidado. (5) Extract Method vamos a reducir la complejidad de la condici\u00f3n. Podr\u00edamos utilizar el operador \"bang\" \u00b4(!)\u00b4 para negar la condici\u00f3n. La verdad es que hay mucho debate en torno a si es legible o no ese operador, yo prefiero utilizarlo lo menos posible ya que muchas veces dificulta bastante la lectura, sobre todo cuando se trata de comparaciones m\u00e1s complejas. Prefiero extraer a un m\u00e9todo la comparaci\u00f3n y darle un valor sem\u00e1ntico al nombre del m\u00e9todo, por ejemplo isDefaultDelimiter . Ahora el c\u00f3digo queda m\u00e1s claro, ya no existe esa animaci\u00f3n de if y las condiciones son m\u00e1s f\u00e1ciles de leer.","title":"Desarrollo"},{"location":"step7/#resultado-final","text":"Deber\u00edamos tener el siguiente c\u00f3digo: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 public class StringCalculator { private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = delimiter . substring ( START_LONG_DELIMITER_TOKEN . length (), ( delimiter . length () - END_LONG_DELIMITER_TOKEN . length ())); } return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final"},{"location":"step8/","text":"Desarrollo del requisito 8 Requisito Permite m\u00faltiples delimitadores de la siguiente manera: '//[delim1][delim2]\\n'. Por ejemplo: \"//[#][%]\\n1#2%3\" debe dar como resultado 6. Desarrollo Al igual que el requisito anterior, nos centraremos en el m\u00e9todo \u00b4extractDelimiter\u00b4. En este caso, vamos a intentar utilizar de nuevo las regex . En lugar de un delimitador, ahora podemos tener n delimitadores. Solo tenemos que extraer esos delimitadores de dentro de los separadores, y concatenarlos con el pipe | , para construir un regex . TestStringCalculator 1 2 3 4 5 @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { Pattern p = Pattern . compile ( \"\\\\[(.*?)\\\\]\" ); Matcher m = p . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( m . find ()) { String singleDelimiter = m . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); } return delimiter ; } En este punto solo se me ocurre unos pocos refactors para mejorarlo. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { Pattern p = Pattern . compile ( \"\\\\[(.*?)\\\\]\" ); /*(1)(2)*/ Matcher m = p . matcher ( delimiter ); /*(1)*/ StringBuilder regexDelimiter = new StringBuilder (); while ( m . find ()) { /*(1)*/ String singleDelimiter = m . group ( 1 ); /*(1)*/ regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); } return delimiter ; } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private static final String EXTRACT_DELIMITER_REGEX = \"\\\\[(.*?)\\\\]\" ; private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); /*(3)*/ Matcher regexMatcher = regexPattern . matcher ( delimiter ); /*(3)*/ StringBuilder regexDelimiter = new StringBuilder (); /*(3)*/ while ( regexMatcher . find ()) { /*(3)*/ String singleDelimiter = regexMatcher . group ( 1 ); /*(3)*/ regexDelimiter . append ( singleDelimiter ); /*(3)*/ regexDelimiter . append ( \"|\" ); /*(3)*/ } /*(3)*/ regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); /*(3)*/ delimiter = regexDelimiter . toString (); /*(3)*/ } return delimiter ; } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = extractMultipleDelimiterFromRegex ( delimiter ); } return delimiter ; } private String extractMultipleDelimiterFromRegex ( String delimiter ) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); Matcher regexMatcher = regexPattern . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( regexMatcher . find ()) { String singleDelimiter = regexMatcher . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); return delimiter ; } Refactoring (1) Las variables p y m no son muy intuitivas, as\u00ed que vamos a ponerles un nombre m\u00e1s coherente. Las llamaremos regexPattern y regexMatcher , por ejemplo. (2) Magic Number , lo extraemos a una constante. (3) Este bloque de c\u00f3digo, hace muchas cosas, vamos a extraerlo a un m\u00e9todo con un nombre bien legible, por ejemplo extractMultipleDelimiterFromRegex . Aun se puede hacer mas Refactoring pero creo que lo dejaremos aqu\u00ed. Resultado final El c\u00f3digo actual es este: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 public class StringCalculator { private static final String EXTRACT_DELIMITER_REGEX = \"\\\\[(.*?)\\\\]\" ; private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = extractMultipleDelimiterFromRegex ( delimiter ); } return delimiter ; } private String extractMultipleDelimiterFromRegex ( String delimiter ) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); Matcher regexMatcher = regexPattern . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( regexMatcher . find ()) { String singleDelimiter = regexMatcher . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"R8. Varios delimitadores"},{"location":"step8/#desarrollo-del-requisito-8","text":"","title":"Desarrollo del requisito 8"},{"location":"step8/#requisito","text":"Permite m\u00faltiples delimitadores de la siguiente manera: '//[delim1][delim2]\\n'. Por ejemplo: \"//[#][%]\\n1#2%3\" debe dar como resultado 6.","title":"Requisito"},{"location":"step8/#desarrollo","text":"Al igual que el requisito anterior, nos centraremos en el m\u00e9todo \u00b4extractDelimiter\u00b4. En este caso, vamos a intentar utilizar de nuevo las regex . En lugar de un delimitador, ahora podemos tener n delimitadores. Solo tenemos que extraer esos delimitadores de dentro de los separadores, y concatenarlos con el pipe | , para construir un regex . TestStringCalculator 1 2 3 4 5 @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { Pattern p = Pattern . compile ( \"\\\\[(.*?)\\\\]\" ); Matcher m = p . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( m . find ()) { String singleDelimiter = m . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); } return delimiter ; } En este punto solo se me ocurre unos pocos refactors para mejorarlo. StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { Pattern p = Pattern . compile ( \"\\\\[(.*?)\\\\]\" ); /*(1)(2)*/ Matcher m = p . matcher ( delimiter ); /*(1)*/ StringBuilder regexDelimiter = new StringBuilder (); while ( m . find ()) { /*(1)*/ String singleDelimiter = m . group ( 1 ); /*(1)*/ regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); } return delimiter ; } StringCalculator-Ref1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private static final String EXTRACT_DELIMITER_REGEX = \"\\\\[(.*?)\\\\]\" ; private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); /*(3)*/ Matcher regexMatcher = regexPattern . matcher ( delimiter ); /*(3)*/ StringBuilder regexDelimiter = new StringBuilder (); /*(3)*/ while ( regexMatcher . find ()) { /*(3)*/ String singleDelimiter = regexMatcher . group ( 1 ); /*(3)*/ regexDelimiter . append ( singleDelimiter ); /*(3)*/ regexDelimiter . append ( \"|\" ); /*(3)*/ } /*(3)*/ regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); /*(3)*/ delimiter = regexDelimiter . toString (); /*(3)*/ } return delimiter ; } StringCalculator-Ref2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = extractMultipleDelimiterFromRegex ( delimiter ); } return delimiter ; } private String extractMultipleDelimiterFromRegex ( String delimiter ) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); Matcher regexMatcher = regexPattern . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( regexMatcher . find ()) { String singleDelimiter = regexMatcher . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); return delimiter ; } Refactoring (1) Las variables p y m no son muy intuitivas, as\u00ed que vamos a ponerles un nombre m\u00e1s coherente. Las llamaremos regexPattern y regexMatcher , por ejemplo. (2) Magic Number , lo extraemos a una constante. (3) Este bloque de c\u00f3digo, hace muchas cosas, vamos a extraerlo a un m\u00e9todo con un nombre bien legible, por ejemplo extractMultipleDelimiterFromRegex . Aun se puede hacer mas Refactoring pero creo que lo dejaremos aqu\u00ed.","title":"Desarrollo"},{"location":"step8/#resultado-final","text":"El c\u00f3digo actual es este: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 public class StringCalculator { private static final String EXTRACT_DELIMITER_REGEX = \"\\\\[(.*?)\\\\]\" ; private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = extractMultipleDelimiterFromRegex ( delimiter ); } return delimiter ; } private String extractMultipleDelimiterFromRegex ( String delimiter ) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); Matcher regexMatcher = regexPattern . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( regexMatcher . find ()) { String singleDelimiter = regexMatcher . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final"},{"location":"step9/","text":"Desarrollo del requisito 9 Requisito Aseg\u00farate de que puedes manejar delimitadores de cualquier longitud mayor de un caracter. Desarrollo Este requisito es muy sencillo, vamos a a\u00f1adirlo en el \u00faltimo test que hicimos, ya que es un caso de prueba m\u00e1s pero dentro del mismo test. TestStringCalculator 1 2 3 4 5 6 @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;][##]\\n1;;2##3\" )); } Si lo ejecutamos, el test funciona correctamente porque ya lo hab\u00edamos implementado para m\u00faltiples delimitadores con el tama\u00f1o variable. As\u00ed que ya tenemos toda la kata terminada. Resultado final de la Kata El c\u00f3digo final del ejercicio nos ha quedado as\u00ed: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;][##]\\n1;;2##3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 public class StringCalculator { private static final String EXTRACT_DELIMITER_REGEX = \"\\\\[(.*?)\\\\]\" ; private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = extractMultipleDelimiterFromRegex ( delimiter ); } return delimiter ; } private String extractMultipleDelimiterFromRegex ( String delimiter ) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); Matcher regexMatcher = regexPattern . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( regexMatcher . find ()) { String singleDelimiter = regexMatcher . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"R9. Varios delimitadores largos"},{"location":"step9/#desarrollo-del-requisito-9","text":"","title":"Desarrollo del requisito 9"},{"location":"step9/#requisito","text":"Aseg\u00farate de que puedes manejar delimitadores de cualquier longitud mayor de un caracter.","title":"Requisito"},{"location":"step9/#desarrollo","text":"Este requisito es muy sencillo, vamos a a\u00f1adirlo en el \u00faltimo test que hicimos, ya que es un caso de prueba m\u00e1s pero dentro del mismo test. TestStringCalculator 1 2 3 4 5 6 @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;][##]\\n1;;2##3\" )); } Si lo ejecutamos, el test funciona correctamente porque ya lo hab\u00edamos implementado para m\u00faltiples delimitadores con el tama\u00f1o variable. As\u00ed que ya tenemos toda la kata terminada.","title":"Desarrollo"},{"location":"step9/#resultado-final-de-la-kata","text":"El c\u00f3digo final del ejercicio nos ha quedado as\u00ed: TestStringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 public class TestStringCalculator { @Rule public final ExpectedException exception = ExpectedException . none (); private StringCalculator calculator = new StringCalculator (); @Test public void empty_string_return_zero () { Assert . assertEquals ( 0 , this . calculator . add ( \"\" )); } @Test public void one_number_return_this_number () { Assert . assertEquals ( 1 , this . calculator . add ( \"1\" )); Assert . assertEquals ( 2 , this . calculator . add ( \"2\" )); Assert . assertEquals ( 13 , this . calculator . add ( \"13\" )); } @Test public void two_comma_separated_number_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2\" )); Assert . assertEquals ( 40 , this . calculator . add ( \"17,23\" )); } @Test public void multiple_comma_separated_number_return_sum () { Assert . assertEquals ( 6 , this . calculator . add ( \"1,2,3\" )); Assert . assertEquals ( 25 , this . calculator . add ( \"4,5,6,10\" )); Assert . assertEquals ( 51 , this . calculator . add ( \"10,10,10,10,10,1\" )); } @Test public void comma_or_return_line_separated_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1\\n2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"1\\n2,3\" )); } @Test public void any_delimited_numbers_return_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"//;\\n1;2\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//d\\n1d2d3\" )); } @Test public void negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1\" ); this . calculator . add ( \"-1\" ); } @Test public void multiple_negative_number_throw_exception () { this . exception . expect ( RuntimeException . class ); this . exception . expectMessage ( \"negativos no soportados: -1,-2\" ); this . calculator . add ( \"-1,-2\" ); } @Test public void numbers_greater_than_thousand_not_sum () { Assert . assertEquals ( 3 , this . calculator . add ( \"1,2,1001\" )); } @Test public void any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;;]\\n1;;;2;;;3\" )); } @Test public void multiple_any_length_delimiter () { Assert . assertEquals ( 6 , this . calculator . add ( \"//[#][%]\\n1#2%3\" )); Assert . assertEquals ( 6 , this . calculator . add ( \"//[;;][##]\\n1;;2##3\" )); } } StringCalculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 public class StringCalculator { private static final String EXTRACT_DELIMITER_REGEX = \"\\\\[(.*?)\\\\]\" ; private static final String END_LONG_DELIMITER_TOKEN = \"]\" ; private static final String START_LONG_DELIMITER_TOKEN = \"[\" ; private static final int MAXIMUM_NUMBER_ALLOWED = 1000 ; private static final String END_DELIMITER_TOKEN = \"\\n\" ; private static final String START_DELIMITER_TOKEN = \"//\" ; private static final String DEFAULT_DELIMITER = \",|\\n\" ; private static final String EMPTY_INPUT = \"\" ; private static final int EMPTY_RESULT = 0 ; public int add ( String input ) { if ( EMPTY_INPUT . equals ( input )) return EMPTY_RESULT ; String delimiter = extractDelimiter ( input ); String [] numbers = extractNumbers ( input , delimiter ); checkNegativeNumbers ( numbers ); return addNumbers ( numbers ); } private void checkNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = getNegativeNumbers ( numbers ); if ( negativeNumbers . isEmpty ()) return ; throw new RuntimeException ( \"negativos no soportados: \" + convertListToString ( negativeNumbers )); } private List < String > getNegativeNumbers ( String [] numbers ) { List < String > negativeNumbers = new ArrayList <> (); for ( String number : numbers ) { if ( isNegative ( number )) negativeNumbers . add ( number ); } return negativeNumbers ; } private boolean isNegative ( String number ) { return Integer . parseInt ( number ) < 0 ; } private String convertListToString ( List < String > negativeNumbers ) { StringBuilder sb = new StringBuilder (); for ( String number : negativeNumbers ) { sb . append ( number ); sb . append ( \",\" ); } sb . deleteCharAt ( sb . length () - 1 ); return sb . toString (); } private String [] extractNumbers ( String input , String delimiter ) { if ( input . startsWith ( START_DELIMITER_TOKEN )) { int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); input = input . substring ( endIndex + END_DELIMITER_TOKEN . length ()); } return input . split ( delimiter ); } private String extractDelimiter ( String input ) { if ( isDefaultDelimiter ( input )) return DEFAULT_DELIMITER ; int endIndex = input . indexOf ( END_DELIMITER_TOKEN ); String delimiter = input . substring ( START_DELIMITER_TOKEN . length (), endIndex ); if ( isLongDelimiter ( delimiter )) { delimiter = extractMultipleDelimiterFromRegex ( delimiter ); } return delimiter ; } private String extractMultipleDelimiterFromRegex ( String delimiter ) { Pattern regexPattern = Pattern . compile ( EXTRACT_DELIMITER_REGEX ); Matcher regexMatcher = regexPattern . matcher ( delimiter ); StringBuilder regexDelimiter = new StringBuilder (); while ( regexMatcher . find ()) { String singleDelimiter = regexMatcher . group ( 1 ); regexDelimiter . append ( singleDelimiter ); regexDelimiter . append ( \"|\" ); } regexDelimiter . deleteCharAt ( regexDelimiter . length () - 1 ); delimiter = regexDelimiter . toString (); return delimiter ; } private boolean isDefaultDelimiter ( String input ) { return input . startsWith ( START_DELIMITER_TOKEN ) == false ; } private boolean isLongDelimiter ( String delimiter ) { return delimiter . startsWith ( START_LONG_DELIMITER_TOKEN ) && delimiter . endsWith ( END_LONG_DELIMITER_TOKEN ); } private int addNumbers ( String numbers [] ) { int total = 0 ; for ( String number : numbers ) { int parsedNumber = Integer . parseInt ( number ); if ( parsedNumber <= MAXIMUM_NUMBER_ALLOWED ) total += Integer . parseInt ( number ); } return total ; } }","title":"Resultado final de la Kata"}]}